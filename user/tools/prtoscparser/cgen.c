/*
 * FILE: cgen.c
 *
 * Dumps the information in C format
 *
 * www.prtos.com
 */

#include <prtos_inc/linkage.h>
#include <stdio.h>
#include <prtos_inc/arch/paging.h>
#include <prtos_inc/arch/asm_offsets.h>
#include <prtos_inc/guest.h>
#include "common.h"
#include "prtos_conf.h"

#define PRTOSC_C_HEADER                                       \
    "/* File generated by prtoscparser. Don't modify. */\n\n" \
    "#include <prtos_inc/prtosconf.h>\n\n"

#define PRINT_PREF

static inline void generate_hm(FILE *out_file, struct prtos_conf_hm_slot *hm_table) {
    extern char *hm_actions[];
    extern char *hm_events[];
    extern char *hm_log[];
    int i;
    fprintf(out_file, ADDNTAB(1, ".hm_table = {\n"));
    for (i = 0; i < PRTOS_HM_MAX_EVENTS; i++)
        if (hm_events[i])
            fprintf(out_file, ADDNTAB(2, "[%s] = {.action = %s, .log = %s },\n"), hm_events[i], hm_actions[hm_table[i].action], hm_log[hm_table[i].log]);

    fprintf(out_file, ADDNTAB(1, "},\n"));
}

static inline void generate_region_table(FILE *out_file) {
    int e;
    fprintf(out_file, "const struct prtos_conf_memory_region prtos_conf_mem_reg_table[] = {\n");

    for (e = 0; e < prtos_conf.num_of_regions; e++) {
        fprintf(out_file,
                ADDNTAB(1, "[%d] = {\n") ADDNTAB(2, ".start_addr = 0x%" PRINT_PREF "x,\n") ADDNTAB(2, ".size = %" PRINT_PREF "u,\n")
                    ADDNTAB(2, ".flags = 0x%x,\n") ADDNTAB(1, "},\n"),
                e, prtos_conf_mem_reg_table[e].start_addr, prtos_conf_mem_reg_table[e].size, prtos_conf_mem_reg_table[e].flags);
    }

    fprintf(out_file, "};\n\n");
}

static inline void generate_phys_mem_area_table(FILE *out_file) {
    int i;
    fprintf(out_file, "const struct prtos_conf_memory_area prtos_conf_phys_mem_area_table[] = {\n");
    for (i = 0; i < prtos_conf.num_of_physical_memory_areas; i++) {
        fprintf(out_file, ADDNTAB(1, "[%d] = {\n"), i);
        fprintf(out_file, ADDNTAB(2, ".name_offset = %u,\n"), prtos_conf_mem_area_table[i].name_offset);
        fprintf(out_file, ADDNTAB(2, ".start_addr = 0x%" PRINT_PREF "x,\n"), prtos_conf_mem_area_table[i].start_addr);
        fprintf(out_file, ADDNTAB(2, ".mapped_at = 0x%" PRINT_PREF "x,\n"), prtos_conf_mem_area_table[i].mapped_at);
        fprintf(out_file, ADDNTAB(2, ".size = %" PRINT_PREF "u,\n"), prtos_conf_mem_area_table[i].size);
        fprintf(out_file, ADDNTAB(2, ".flags = 0x%x,\n"), prtos_conf_mem_area_table[i].flags);
        fprintf(out_file, ADDNTAB(2, ".memory_region_offset = 0x%x,\n"), prtos_conf_mem_area_table[i].memory_region_offset);
        fprintf(out_file, ADDNTAB(1, "},\n"));
    }
    fprintf(out_file, "};\n\n");
}

static inline void generate_cyclic_slots(FILE *out_file) {
    int j;
    fprintf(out_file, "const struct prtos_conf_sched_cyclic_slot prtos_conf_sched_cyclic_slot_table[] = {\n");
    for (j = 0; j < prtos_conf.num_of_sched_cyclic_slots; j++) {
        fprintf(out_file,
                ADDNTAB(1, "[%d] = {\n") ADDNTAB(2, ".id = 0x%x,\n") ADDNTAB(2, ".partition_id = %d,\n") ADDNTAB(2, ".vcpu_id = %d,\n")
                    ADDNTAB(2, ".start_exec = %d,\n") ADDNTAB(2, ".end_exec = %d,\n") ADDNTAB(1, "},\n"),
                j, prtos_conf_sched_cyclic_slot_table[j].id, prtos_conf_sched_cyclic_slot_table[j].partition_id, prtos_conf_sched_cyclic_slot_table[j].vcpu_id,
                prtos_conf_sched_cyclic_slot_table[j].start_exec, prtos_conf_sched_cyclic_slot_table[j].end_exec);
    }
    fprintf(out_file, "};\n\n");
}

static inline void generate_cyclic_plans(FILE *out_file) {
    int j;
    fprintf(out_file, "const struct prtos_conf_sched_cyclic_plan prtos_conf_sched_cyclic_plan_table[] = {\n");
    for (j = 0; j < prtos_conf.num_of_sched_cyclic_plans; j++) {
        fprintf(out_file,
                ADDNTAB(1, "[%d] = {\n") ADDNTAB(2, ".name_offset = %d,\n") ADDNTAB(2, ".id = 0x%x,\n") ADDNTAB(2, ".major_frame = %u,\n")
#ifdef CONFIG_PLAN_EXTSYNC
                    ADDNTAB(2, ".ext_sync = %d,\n")
#endif
                        ADDNTAB(2, ".num_of_slotss = %d,\n") ADDNTAB(2, ".slots_offset = %d,\n") ADDNTAB(1, "},\n"),
                j, prtos_conf_sched_cyclic_plan_table[j].name_offset, prtos_conf_sched_cyclic_plan_table[j].id,
                prtos_conf_sched_cyclic_plan_table[j].major_frame,
#ifdef CONFIG_PLAN_EXTSYNC
                prtos_conf_sched_cyclic_plan_table[j].ext_sync,
#endif
                prtos_conf_sched_cyclic_plan_table[j].num_of_slotss, prtos_conf_sched_cyclic_plan_table[j].slots_offset);
    }
    fprintf(out_file, "};\n\n");
}

static inline void generate_dev(FILE *out_file, char name[], prtos_dev_t *dev) {
    fprintf(out_file, ADDNTAB(1, ".%s = { .id= 0x%x, .sub_id = 0x%x,},\n"), name, dev->id, dev->sub_id);
}

static inline void generate_trace(FILE *out_file, struct prtos_conf_trace *trace) {
    fprintf(out_file, ADDNTAB(1, ".trace = {\n"));
    generate_dev(out_file, "dev", &trace->dev);
    fprintf(out_file, ADDNTAB(2, ".bitmap = 0x%x,\n"), trace->bitmap);
    fprintf(out_file, ADDNTAB(1, "},\n"));
}

static inline void generate_comm_channel_table(FILE *out_file) {
    int e;
    fprintf(out_file, "const struct prtos_conf_comm_channel prtos_conf_comm_channel_table[] = {\n");

    for (e = 0; e < prtos_conf.num_of_comm_channels; e++) {
        fprintf(out_file, ADDNTAB(1, "[%d] = {\n") ADDNTAB(2, ".type = "), e);

        switch (prtos_conf_comm_channel_table[e].type) {
            case PRTOS_SAMPLING_CHANNEL:
                fprintf(out_file,
                        "PRTOS_SAMPLING_CHANNEL,\n" ADDNTAB(2, "{.s.max_length = %d,\n") ADDNTAB(2, ".s.valid_period = %u,\n")
                            ADDNTAB(2, ".s.num_of_receivers = %d, },\n"),
                        prtos_conf_comm_channel_table[e].s.max_length, prtos_conf_comm_channel_table[e].s.valid_period,
                        prtos_conf_comm_channel_table[e].s.num_of_receivers);
                break;
            case PRTOS_QUEUING_CHANNEL:
                fprintf(out_file, "PRTOS_QUEUING_CHANNEL,\n" ADDNTAB(2, "{.q.max_length = %d,\n") ADDNTAB(2, ".q.max_num_of_msgs = %d, },\n"),
                        prtos_conf_comm_channel_table[e].q.max_length, prtos_conf_comm_channel_table[e].q.max_num_of_msgs);
                break;
        }

        fprintf(out_file, ADDNTAB(1, "},\n"));
    }

    fprintf(out_file, "};\n\n");
}

static inline void generate_comm_port_table(FILE *out_file) {
    int e;
    fprintf(out_file, "const struct prtos_conf_comm_port prtos_conf_comm_ports[] = {\n");
    for (e = 0; e < prtos_conf.num_of_comm_ports; e++) {
        fprintf(out_file, ADDNTAB(1, "[%d] = {\n") ADDNTAB(2, ".name_offset = %d,\n") ADDNTAB(2, ".channel_id = "), e,
                prtos_conf_comm_port_table[e].name_offset);

        if (prtos_conf_comm_port_table[e].channel_id == PRTOS_NULL_CHANNEL) {
            fprintf(out_file, "PRTOS_NULL_CHANNEL, \n");
        } else {
            fprintf(out_file, "%d, \n", prtos_conf_comm_port_table[e].channel_id);
        }

        fprintf(out_file, ADDNTAB(2, ".direction = "));

        switch (prtos_conf_comm_port_table[e].direction) {
            case PRTOS_SOURCE_PORT:
                fprintf(out_file, "PRTOS_SOURCE_PORT, \n");
                break;
            case PRTOS_DESTINATION_PORT:
                fprintf(out_file, "PRTOS_DESTINATION_PORT, \n");
                break;
        }

        fprintf(out_file, ADDNTAB(2, ".type = "));
        switch (prtos_conf_comm_port_table[e].type) {
            case PRTOS_SAMPLING_PORT:
                fprintf(out_file, "PRTOS_SAMPLING_PORT, \n");
                break;
            case PRTOS_QUEUING_PORT:
                fprintf(out_file, "PRTOS_QUEUING_PORT, \n");
                break;
        }

        fprintf(out_file, ADDNTAB(1, "},\n"));

        //.id= 0x0, .sub_id = 0x0,},
    }
    fprintf(out_file, "};\n\n");
}

static inline void generate_ipvi_table(FILE *out_file) {
    int e;
    fprintf(out_file, "const prtos_u8_t prtoscIpviDstTab[] = { ");
    for (e = 0; e < prtos_conf.num_of_ipvi_dsts; e++) fprintf(out_file, "%d, ", ipvi_dst_table[e]);
    fprintf(out_file, "};\n\n");
}

static inline void generate_hpv(FILE *out_file) {
    int e;
    fprintf(out_file, ADDNTAB(1, ".hpv = {\n"));
    fprintf(out_file, ADDNTAB(2, ".num_of_physical_memory_areas = %d,\n"), prtos_conf.hpv.num_of_physical_memory_areas);
    fprintf(out_file, ADDNTAB(2, ".physical_memory_areas_offset = %d,\n"), prtos_conf.hpv.physical_memory_areas_offset);
    fprintf(out_file, ADDNTAB(2, ".num_of_cpus = %d,\n") ADDNTAB(2, ".cpu_table = {\n"), prtos_conf.hpv.num_of_cpus);

    for (e = 0; e < prtos_conf.hpv.num_of_cpus; e++) {
        fprintf(out_file, ADDNTAB(3, "[%d] = {\n") ADDNTAB(4, ".id = %d,\n") ADDNTAB(4, ".features = 0x%x,\n") ADDNTAB(4, ".freq = "), e,
                prtos_conf.hpv.cpu_table[e].id, prtos_conf.hpv.cpu_table[e].features);

        if (!prtos_conf.hpv.cpu_table[e].freq)
            fprintf(out_file, "PRTOS_CPUFREQ_AUTO,\n");
        else
            fprintf(out_file, "%u,\n", prtos_conf.hpv.cpu_table[e].freq);
        fprintf(out_file, ADDNTAB(4, ".sched_cyclic_plans_offset = %d,\n") ADDNTAB(4, ".num_of_sched_cyclic_plans = %d,\n"),
                prtos_conf.hpv.cpu_table[e].sched_cyclic_plans_offset, prtos_conf.hpv.cpu_table[e].num_of_sched_cyclic_plans);
        fprintf(out_file, ADDNTAB(4, ".sched_policy = %d,\n"), prtos_conf.hpv.cpu_table[e].sched_policy);
        fprintf(out_file, ADDNTAB(3, "},\n"));
    }

    fprintf(out_file, ADDNTAB(2, "},\n"));
    generate_hm(out_file, prtos_conf.hpv.hm_table);
    fprintf(out_file, ADDNTAB(2, ".hw_irq_table = {\n"));

    for (e = 0; e < CONFIG_NO_HWIRQS; e++) {
        fprintf(out_file, ADDNTAB(3, "[%d] = {.owner = "), e);

        if (prtos_conf.hpv.hw_irq_table[e].owner == PRTOS_IRQ_NO_OWNER)
            fprintf(out_file, "PRTOS_IRQ_NO_OWNER, },\n");
        else
            fprintf(out_file, "%d, },\n", prtos_conf.hpv.hw_irq_table[e].owner);
    }
    fprintf(out_file, ADDNTAB(2, "},\n"));
    generate_trace(out_file, &prtos_conf.hpv.trace);
    generate_dev(out_file, "console_device", &prtos_conf.hpv.console_device);
    generate_dev(out_file, "hm_device", &prtos_conf.hpv.hm_device);
    fprintf(out_file, ADDNTAB(2, ".node_id = %d,\n"), prtos_conf.hpv.node_id);
    fprintf(out_file, ADDNTAB(1, "},\n"));
}

static inline void generate_rsw(FILE *out_file) {
    fprintf(out_file, ADDNTAB(1, ".rsw = {\n"));
    fprintf(out_file, ADDNTAB(2, ".num_of_physical_memory_areas = %d,\n"), prtos_conf.rsw.num_of_physical_memory_areas);
    fprintf(out_file, ADDNTAB(2, ".physical_memory_areas_offset = %d,\n"), prtos_conf.rsw.physical_memory_areas_offset);
    fprintf(out_file, ADDNTAB(1, "},\n"));
}

static inline void generate_partition_tab(FILE *out_file) {
    int e, num_of_vcpus, i;

    fprintf(out_file, "struct prtos_conf_boot_part prtos_conf_boot_part_table[%d];\n", prtos_conf.num_of_partitions);

    fprintf(out_file, "const struct prtos_conf_part prtos_conf_part_table[] = {\n");
    for (e = 0, num_of_vcpus = 0; e < prtos_conf.num_of_partitions; e++, num_of_vcpus += prtos_conf_part_table[e].num_of_vcpus) {
        fprintf(out_file, ADDNTAB(1, "[%d] = {\n") ADDNTAB(2, ".id = %d,\n") ADDNTAB(2, ".name_offset = %d,\n") ADDNTAB(2, ".flags = 0x%x,\n"), e,
                prtos_conf_part_table[e].id, prtos_conf_part_table[e].name_offset, prtos_conf_part_table[e].flags);
        fprintf(out_file, ADDNTAB(2, ".num_of_vcpus = %d,\n"), prtos_conf_part_table[e].num_of_vcpus);
        fprintf(out_file, ADDNTAB(2, ".hw_irqs = 0x%x,\n"), prtos_conf_part_table[e].hw_irqs);
        generate_dev(out_file, "console_device", &prtos_conf_part_table[e].console_device);
        fprintf(out_file, ADDNTAB(2, ".num_of_physical_memory_areas = %d,\n") ADDNTAB(2, ".physical_memory_areas_offset = %d,\n"),
                prtos_conf_part_table[e].num_of_physical_memory_areas, prtos_conf_part_table[e].physical_memory_areas_offset);
        generate_hm(out_file, prtos_conf_part_table[e].hm_table);
        fprintf(out_file, ADDNTAB(2, ".noPorts = %d,\n") ADDNTAB(2, ".comm_ports_offset = %d,\n"), prtos_conf_part_table[e].noPorts,
                prtos_conf_part_table[e].comm_ports_offset);

        fprintf(out_file, ADDNTAB(2, ".io_ports_offset = %d,\n"), prtos_conf_part_table[e].io_ports_offset);
        fprintf(out_file, ADDNTAB(2, ".num_of_io_ports = %d,\n"), prtos_conf_part_table[e].num_of_io_ports);
        generate_trace(out_file, &prtos_conf_part_table[e].trace);
        fprintf(out_file, ADDNTAB(2, ".ipvi_table = {\n"));
        for (i = 0; i < CONFIG_PRTOS_MAX_IPVI; i++) {
            fprintf(out_file, ADDNTAB(3, "[%d] = {\n"), i);
            fprintf(out_file, ADDNTAB(4, ".dst_offset = %d,\n"), prtos_conf_part_table[e].ipvi_table[i].dst_offset);
            fprintf(out_file, ADDNTAB(4, ".num_of_dsts = %d,\n"), prtos_conf_part_table[e].ipvi_table[i].num_of_dsts);
            fprintf(out_file, ADDNTAB(3, "},\n"));
        }
        fprintf(out_file, ADDNTAB(2, "},\n"));
        fprintf(out_file, ADDNTAB(1, "},\n"));
    }
    fprintf(out_file, "};\n\n");
}

static inline void generate_string_tab(FILE *out_file) {
    int i;
    /* String Table */
    fprintf(out_file, "const char prtos_conf_string_tab[] = {");
    for (i = 0; i < prtos_conf.string_table_length; i++) fprintf(out_file, ADDNTAB(1, "0x%x, "), str_tables[i]);
    fprintf(out_file, "};\n\n");
}

static inline void generate_system_devices(FILE *out_file) {
#if defined(CONFIG_DEV_MEMBLOCK) || defined(CONFIG_DEV_MEMBLOCK_MODULE)
    int e;
    fprintf(out_file, "const struct prtos_conf_mem_block prtos_conf_mem_block_table[]={\n");

    for (e = 0; e < prtos_conf.device_table.num_of_mem_blocks; e++) {
        fprintf(out_file, ADDNTAB(1, "[%d] = {\n"), e);
        fprintf(out_file, ADDNTAB(2, ".physical_memory_areas_offset = %d,\n"), prtos_conf_mem_block_table[e].physical_memory_areas_offset);
        fprintf(out_file, ADDNTAB(1, "},\n"));
    }
    fprintf(out_file, "};\n\n");
#endif
}

static inline void generate_prtos_config(FILE *out_file) {
    int e;
    fprintf(out_file, "struct prtos_conf_rsw_info prtos_conf_rsw_info;\n\n");
    fprintf(out_file,
            "const struct prtos_conf prtos_conf __attribute__ ((section(\".rodata.hdr\"))) = {\n" ADDNTAB(1, ".signature = PRTOSC_SIGNATURE,\n")
                ADDNTAB(1, ".dataSize = (prtos_u_size_t)_dataSize,\n") ADDNTAB(1, ".size = (prtos_u_size_t)_prtoscSize,\n")
                    ADDNTAB(1, ".version = PRTOSC_SET_VERSION(%d, %d, %d),\n") ADDNTAB(1, ".file_version = PRTOSC_SET_VERSION(%d, %d, %d),\n")
                        ADDNTAB(1, ".rsv_mem_tab_offset = (prtos_address_t)_mem_obj_table,\n") ADDNTAB(1, ".name_offset = %" PRINT_PREF "d,\n"),
            PRTOSC_VERSION, PRTOSC_SUBVERSION, PRTOSC_REVISION, PRTOSC_GET_VERSION(prtos_conf.file_version), PRTOSC_GET_SUBVERSION(prtos_conf.file_version),
            PRTOSC_GET_REVISION(prtos_conf.file_version), prtos_conf.name_offset);
    generate_hpv(out_file);
    generate_rsw(out_file);
    fprintf(out_file, ADDNTAB(1, ".part_table_offset = (prtos_address_t)prtos_conf_part_table,\n"));
    fprintf(out_file, ADDNTAB(1, ".num_of_partitions = %d,\n"), prtos_conf.num_of_partitions);

    fprintf(out_file, ADDNTAB(1, ".boot_part_table_offset = (prtos_address_t)prtos_conf_boot_part_table,\n"));
    fprintf(out_file, ADDNTAB(1, ".rsw_info_offset = (prtos_address_t)&prtos_conf_rsw_info,\n"));
    fprintf(out_file, ADDNTAB(1, ".memory_regions_offset = (prtos_address_t)prtos_conf_mem_reg_table,\n") ADDNTAB(1, ".num_of_regions = %d,\n"),
            prtos_conf.num_of_regions);
    fprintf(out_file,
            ADDNTAB(1, ".physical_memory_areas_offset = (prtos_address_t)prtos_conf_phys_mem_area_table,\n")
                ADDNTAB(1, ".num_of_physical_memory_areas = %d,\n"),
            prtos_conf.num_of_physical_memory_areas);
    fprintf(out_file,
            ADDNTAB(1, ".sched_cyclic_slots_offset = (prtos_address_t)prtos_conf_sched_cyclic_slot_table,\n") ADDNTAB(1, ".num_of_sched_cyclic_slots = %d,\n"),
            prtos_conf.num_of_sched_cyclic_slots);

    fprintf(out_file,
            ADDNTAB(1, ".sched_cyclic_plans_offset = (prtos_address_t)prtos_conf_sched_cyclic_plan_table,\n") ADDNTAB(1, ".num_of_sched_cyclic_plans = %d,\n"),
            prtos_conf.num_of_sched_cyclic_plans);
    fprintf(out_file, ADDNTAB(1, ".comm_channel_table_offset = (prtos_address_t)prtos_conf_comm_channel_table,\n") ADDNTAB(1, ".num_of_comm_channels = %d,\n"),
            prtos_conf.num_of_comm_channels);
    fprintf(out_file, ADDNTAB(1, ".comm_ports_offset = (prtos_address_t)prtos_conf_comm_ports,\n") ADDNTAB(1, ".num_of_comm_ports = %d,\n"),
            prtos_conf.num_of_comm_ports);

    fprintf(out_file, ADDNTAB(1, ".io_ports_offset = (prtos_address_t)prtos_conf_io_port_table,\n") ADDNTAB(1, ".num_of_io_ports = %d,\n"),
            prtos_conf.num_of_io_ports);

    fprintf(out_file, ADDNTAB(1, ".ipvi_dst_offset = (prtos_address_t)prtoscIpviDstTab,\n") ADDNTAB(1, ".num_of_ipvi_dsts = %d,\n"),
            prtos_conf.num_of_ipvi_dsts);

    fprintf(out_file, ADDNTAB(1, ".vcpu_table_offset = (prtos_address_t)&prtos_conf_vcpu_table[0][0],\n"));
    fprintf(out_file, ADDNTAB(1, ".strings_offset = (prtos_address_t)prtos_conf_string_tab,\n") ADDNTAB(1, ".string_table_length = %d,\n"),
            prtos_conf.string_table_length);

    fprintf(out_file, ADDNTAB(1, ".device_table = {\n"));
#if defined(CONFIG_DEV_MEMBLOCK) || defined(CONFIG_DEV_MEMBLOCK_MODULE)
    fprintf(out_file, ADDNTAB(2, ".mem_blocks_offset = (prtos_address_t)prtos_conf_mem_block_table,\n"));
    fprintf(out_file, ADDNTAB(2, ".num_of_mem_blocks = %d,\n"), prtos_conf.device_table.num_of_mem_blocks);
#endif
#if defined(CONFIG_DEV_UART) || defined(CONFIG_DEV_UART_MODULE)
    fprintf(out_file, ADDNTAB(2, ".uart = {\n"));
    for (e = 0; e < CONFIG_DEV_NO_UARTS; e++) fprintf(out_file, ADDNTAB(3, "[%d] = {.baud_rate = %d, },\n"), e, prtos_conf.device_table.uart[e].baud_rate);
    fprintf(out_file, ADDNTAB(2, "},\n"));
#endif
    fprintf(out_file, ADDNTAB(1, "},\n"));
    fprintf(out_file, "};\n");
}

extern void arch_loader_rsv_mem(FILE *out_file);

#ifdef CONFIG_MPU
extern void arch_mpu_rsv_mem(FILE *out_file);
#endif
#ifdef CONFIG_MMU
extern void arch_mmu_rsv_mem(FILE *out_file);
#endif

static void generate_rsv_mem(FILE *out_file) {
    int i, j, num_of_vcpus;

#if defined(CONFIG_SMP) && !defined(CONFIG_ARCH_MMU_BYPASS)
    for (i = 1; i < CONFIG_NO_CPUS; i++) {
#ifndef CONFIG_x86
        rsv_block(CTXTTABSIZE, CTXTTABSIZE, "ctxt_table");
#endif
        rsv_block(PTDL1SIZE, PTDL1SIZE, "ptd_level_1_table");
        rsv_block(PTDL2SIZE, PTDL2SIZE, "ptd_level_2_table");
#ifndef CONFIG_x86
        rsv_block(PTDL3SIZE, PTDL3SIZE, "ptd_level_3_table");
#endif
    }
#endif

    for (i = 0, num_of_vcpus = 0; i < prtos_conf.num_of_partitions; i++) {
        num_of_vcpus += prtos_conf_part_table[i].num_of_vcpus;
        rsv_block(prtos_conf_part_table[i].num_of_vcpus * _KTHREADPTR_T_SIZEOF, ALIGNMENT, "partition's kthread table");
        for (j = 0; j < prtos_conf_part_table[i].num_of_vcpus; j++) {
            rsv_block(_KTHREAD_T_SIZEOF, ALIGNMENT, "kthread");
            rsv_block(_STRUCT_GUEST_SIZEOF, ALIGNMENT, "vcpu");
        }
    }

    // Partitions
    rsv_block(prtos_conf.num_of_partitions * _PARTITION_T_SIZEOF, ALIGNMENT, "scheduler's partitions table");

    for (i = 0; i < prtos_conf.num_of_comm_channels; i++) {
        if (prtos_conf_comm_channel_table[i].type == PRTOS_SAMPLING_CHANNEL) {
            if (prtos_conf_comm_channel_table[i].s.num_of_receivers) {
                rsv_block(prtos_conf_comm_channel_table[i].s.num_of_receivers * _KTHREADPTR_T_SIZEOF, ALIGNMENT, "Sampling channel's receivers");
                rsv_block(prtos_conf_comm_channel_table[i].s.num_of_receivers * sizeof(prtos_s32_t), ALIGNMENT, "Sampling channel's receiver ports");
            }
        }
    }

#ifdef CONFIG_MMU
    rsv_block(prtos_conf.num_of_regions * _STRUCT_PHYSPAGEPTR_SIZEOF, ALIGNMENT, "MMU region tables");
    for (i = 0; i < prtos_conf.num_of_regions; i++)
        if (prtos_conf_mem_reg_table[i].flags & PRTOSC_REG_FLAG_PGTAB)
            rsv_block((prtos_conf_mem_reg_table[i].size / PAGE_SIZE) * _STRUCT_PHYSPAGE_SIZEOF, ALIGNMENT, "MMU region tables");

    arch_mmu_rsv_mem(out_file);
#endif
    for (i = 0; i < prtos_conf.num_of_partitions; i++) {
        rsv_block(prtos_conf_part_table[i].num_of_vcpus *
                      (sizeof(part_ctl_table_t) + sizeof(struct prtos_physical_mem_map) * prtos_conf_part_table[i].num_of_physical_memory_areas +
                       ((prtos_conf_part_table[i].noPorts & ((1 << PRTOS_LOG2_WORD_SZ) - 1))
                            ? (prtos_conf_part_table[i].noPorts >> PRTOS_LOG2_WORD_SZ) + sizeof(prtos_word_t)
                            : (prtos_conf_part_table[i].noPorts >> PRTOS_LOG2_WORD_SZ))),
                  PAGE_SIZE, "partition control tables");
    }
#ifdef CONFIG_MPU
    arch_mpu_rsv_mem(out_file);
#endif
    arch_loader_rsv_mem(out_file);
#if defined(CONFIG_DEV_MEMBLOCK) || defined(CONFIG_DEV_MEMBLOCK_MODULE)
    // Memory Blocks
    rsv_block(prtos_conf.device_table.num_of_mem_blocks * _KDEVICE_T_SIZEOF, ALIGNMENT, "memory block driver");
    rsv_block(prtos_conf.device_table.num_of_mem_blocks * _STRUCT_MEMBLOCKDATA_SIZEOF, ALIGNMENT, "memory block driver");
#endif
    // Cyclic scheduler
    rsv_block(prtos_conf.hpv.num_of_cpus * _STRUCT_SCHEDDATA_SIZEOF, ALIGNMENT, "scheduler data");

    // Console
    rsv_block(prtos_conf.num_of_partitions * _STRUCT_CONSOLE_SIZEOF, ALIGNMENT, "console object");

    // status
    rsv_block(prtos_conf.num_of_partitions * _PRTOS_PART_STATUS_T_SIZEOF, ALIGNMENT, "status object");

    // trace
    rsv_block(prtos_conf.num_of_partitions * _STRUCT_LOGSTREAM_SIZEOF, ALIGNMENT, "trace object");

    // comm ports
    rsv_block(prtos_conf.num_of_comm_channels * _UNION_CHANNEL_SIZEOF, ALIGNMENT, "commport object");
    rsv_block(prtos_conf.num_of_comm_ports * _STRUCT_PORT_SIZEOF, ALIGNMENT, "commport object");
    for (i = 0; i < prtos_conf.num_of_comm_channels; i++) switch (prtos_conf_comm_channel_table[i].type) {
            case PRTOS_SAMPLING_CHANNEL:
                rsv_block(prtos_conf_comm_channel_table[i].s.max_length, ALIGNMENT, "sampling commport object");
                break;
            case PRTOS_QUEUING_CHANNEL:
                rsv_block(prtos_conf_comm_channel_table[i].q.max_num_of_msgs * _STRUCT_MSG_SIZEOF, ALIGNMENT, "queuing commport object");
                for (j = 0; j < prtos_conf_comm_channel_table[i].q.max_num_of_msgs; j++)
                    rsv_block(prtos_conf_comm_channel_table[i].q.max_length, ALIGNMENT, "queuing commport object");

                break;
        }
#if defined(CONFIG_DEV_UART) || defined(CONFIG_DEV_UART_MODULE)
#endif

    print_blocks(out_file);
}

void generate_vcpu_table(FILE *out_file) {
    int part, vcpu, cpu;
    fprintf(out_file, "const struct prtos_conf_vcpu prtos_conf_vcpu_table[%d][%d] = {\n", prtos_conf.num_of_partitions, prtos_conf.hpv.num_of_cpus);
    for (part = 0; part < prtos_conf.num_of_partitions; part++) {
        fprintf(out_file, "{\n");
        for (vcpu = 0; vcpu < prtos_conf_part_table[part].num_of_vcpus && vcpu < prtos_conf.hpv.num_of_cpus; vcpu++) {
            fprintf(out_file, ADDNTAB(1, "{.cpu = %d,},\n"), vcpu_to_cpu_table[part][vcpu].cpu);
        }
        for (cpu = vcpu; cpu < prtos_conf.hpv.num_of_cpus; cpu++) {
            fprintf(out_file, ADDNTAB(1, "{.cpu = %d,},\n"), -1);
        }
        fprintf(out_file, "},\n");
    }
    fprintf(out_file, "};\n\n");
}

void generate_c_file(FILE *out_file) {
    extern void generate_io_port_table(FILE * out_file);
    /* Header */
    fprintf(out_file, PRTOSC_C_HEADER);
    fprintf(out_file, "extern char _prtoscSize[];\n\n");
    fprintf(out_file, "extern char _dataSize[];\n\n");
    fprintf(out_file, "extern char _mem_obj_table[];\n\n");
    generate_region_table(out_file);
    generate_phys_mem_area_table(out_file);
    generate_comm_channel_table(out_file);
    generate_comm_port_table(out_file);
    generate_ipvi_table(out_file);
    generate_cyclic_slots(out_file);
    generate_cyclic_plans(out_file);
    generate_io_port_table(out_file);
    generate_string_tab(out_file);
    generate_system_devices(out_file);
    generate_partition_tab(out_file);

    generate_vcpu_table(out_file);
    generate_prtos_config(out_file);
    generate_rsv_mem(out_file);
}
